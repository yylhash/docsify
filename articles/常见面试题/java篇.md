## **1、ArrayList和linkedList的区别**
**底层数据结构**：

- ArrayList 使用动态数组实现，内部使用数组来存储元素，通过索引快速访问元素。
- LinkedList 使用双向链表实现，内部使用链表结构存储元素，每个节点都包含对前后节点的引用。

**插入和删除操作的性能**：

- ArrayList 在末尾进行插入和删除操作的性能较高，时间复杂度为 O(1)，但在中间或开头插入和删除元素时，需要移动后续元素，时间复杂度为 O(n)。
- LinkedList 在任意位置进行插入和删除操作的性能都较高，时间复杂度为 O(1)，因为只需要修改相邻节点的引用，不需要移动其他元素。

**随机访问的性能**：

- ArrayList 支持随机访问，可以通过索引快速访问元素，时间复杂度为 O(1)。
- LinkedList 不支持随机访问，需要从头或尾部开始遍历链表，时间复杂度为 O(n)。

基于以上区别，一般可以根据具体的场景选择使用 ArrayList 还是 LinkedList：

- 如果需要频繁进行随机访问操作，应选择 ArrayList。
- 如果需要频繁进行插入和删除操作，尤其是在中间位置，应选择 LinkedList。
- 如果需要同时进行随机访问和插入删除操作，需要根据具体的操作频率和数据规模来综合考虑。

## 2、多线程list的使用哪个类保证线程安全
在多线程环境下，如果需要保证对 List 的并发访问安全，可以使用 `java.util.concurrent.CopyOnWriteArrayList` 类。`CopyOnWriteArrayList` 是 `ArrayList` 的线程安全版本，它通过对底层数组进行复制来实现并发访问的安全性。
`CopyOnWriteArrayList` 的底层实现是基于数组。它的主要思想是在写操作时创建一个数组的副本，然后在副本上执行修改操作，最后再将修改后的副本替换原始数组。这样可以保证在读取操作时不会被阻塞，因为读取操作可以同时进行，而不受写操作的影响。

以下是 `CopyOnWriteArrayList` 的主要特点和底层逻辑：

1. **线程安全性**：`CopyOnWriteArrayList` 是线程安全的，它的所有写操作都是原子的，不需要额外的同步措施。这是因为写操作在创建副本时并不影响原始数组，所以读取操作可以在不受影响的原始数组上进行。
2. **读操作**：读取操作在原始数组上执行，因此不会受到写操作的影响，读取操作的性能很高。
3. **写操作**：写操作会在修改副本上执行，因此写操作可能会比较耗时，特别是在数组较大时。但由于写操作不会阻塞读取操作，因此适用于读操作频繁、写操作相对较少的场景。
4. **内存消耗**：由于每次写操作都会创建一个数组的副本，因此 `CopyOnWriteArrayList` 的内存消耗较大，特别是当数组较大时。因此不适用于内存敏感的场景。
5. **迭代器**：`CopyOnWriteArrayList` 的迭代器是快速失败的，即在迭代过程中如果有其他线程对列表进行了修改，迭代器会立即抛出 `ConcurrentModificationException` 异常。

总的来说，`CopyOnWriteArrayList` 适用于读多写少、读操作要求响应速度快且数据量不大的场景，例如监听器列表、事件通知机制等。

## 3、hashmap和hashset的区别有哪些？
### 2. 元素类型：
**HashMap：** 是一个键值对映射集合，
**HashSet：** 是一个无序、唯一元素的集合，

### 2. 存储方式：

- **HashMap：** 存储键值对，每个元素都包含一个键和一个值。键是唯一的，值可以重复。
- **HashSet：** 存储不重复的元素，每个元素是唯一的。
