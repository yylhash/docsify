### 16、Java继承

继承是面向对象的三大特征之一。

Java中的继承就是在已经存在类的基础上进行扩展，从而产生新的类。已经存在的类称为父类、基类或超类，而新产生的类称为子类或派生类。在子类中，不仅包含父类的属性和方法，还可以增加新的属性和方法。

```java
修饰符 class class_name {
    //父类
}
修饰符 class class_name extends extend_class {
    // 类的主体
    //子类
}
```

类的继承不改变类成员的**访问权限**，也就是说，如果父类的成员是公有的、被保护的或默认的，它的子类仍具有相应的这些特性，并且子类不能获得父类的**构造方法**。

#### 16.1 继承的特性

- 子类拥有父类非 private 的属性、方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

#### 16.2 继承的优缺点

在面向对象语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：

1. 实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。
2. 提高代码维护性和可重用性。
3. 提高代码的可扩展性，更好的实现父类的方法。

继承的缺点如下：

1. 继承是侵入性的。只要继承，就必须拥有父类的属性和方法。
2. 降低代码灵活性。子类拥有父类的属性和方法后多了些约束。
3. 增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。

#### 16.3 继承关键字

继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于` java.lang.Object`，当一个类没有继承的两个关键字，则默认继承object（这个类在 `java.lang `包中，所以不需要 **import**）祖先类。

+ `extends`关键字:extends 只能继承一个类。

+ `implements`关键字:使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。

+ `super`关键字：由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。

  + `super `关键字的功能：

    - 在子类的构造方法中显式的调用父类构造方法

    - 访问父类的成员方法和变量。

  + `super`调用父类构造方法

    ```java
    super(parameter-list);
    ```

  + `super `访问父类中的成员

    ```java
    super.member
    ```

  + `this`关键字：`this` 指的是当前对象的引用。

    `this` 关键字的用法：

    + this.属性名：表示当前对象的属性
    + this.方法名(参数)：表示调用当前对象的方法

  + `final` 关键字:

    final 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。

    final 含义为 "最终的"。使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写：

    + 声明类：

    ```java
    final class 类名 {
        //类体
    }
    ```

    + 声明方法：

    ```java
    修饰符(public/private/default/protected) final 返回值类型 方法名(){
        //方法体
    }
    ```

    

#### 16.4 super和this的区别


关于 Java super 和 this 关键字的异同，可简单总结为以下几条。

1. 子类和父类中变量或方法名称相同时，用 super 关键字来访问。可以理解为 super 是指向自己父类对象的一个指针。在子类中调用父类的构造方法。
2. this 是自身的一个对象，代表对象本身，可以理解为 this 是指向对象本身的一个指针。在同一个类中调用其它方法。
3. this 和 super 不能同时出现在一个构造方法里面，因为 this 必然会调用其它的构造方法，其它的构造方法中肯定会有 super 语句的存在，所以在同一个构造方法里面有相同的语句，就失去了语句的意义，编译器也不会通过。
4. this( ) 和 super( ) 都指的是对象，所以，均不可以在 static 环境中使用，包括 static 变量、static 方法和 static 语句块。
5. 从本质上讲，this 是一个指向对象本身的指针, 然而 super 是一个 Java 关键字。

### 17、Java 重写(Override)

在子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override），又称为方法覆盖。当父类中的方法无法满足子类需求或子类具有特有功能的时候，需要方法重写。

在重写方法时，需要遵循下面的规则：

+ 参数列表必须完全与被重写的方法参数列表相同。
+ 返回的类型必须与被重写的方法的返回类型相同。
+ 访问权限不能比父类中被重写方法的访问权限更低（public>protected>default>private）。
+ 重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。
+ 声明为 final 的方法不能被重写。
+ 声明为 final 的方法不能被重写。（但是可以声明）
+ 构造方法不能被重写。
+ 如果不能继承一个方法，则不能重写这个方法。（重写的前提是继承）

### 18、Java重载(Overload)

如果同一个类中包含了两个或两个以上方法名相同的方法，但形参列表不同，这种情况被称为方法重载（**overload**）。

**重载规则:**

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

### 19、Java 多态

多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

**多态的优点**：

- 消除类型之间的耦合关系
- 可替换
- 可扩充性
- 接口性
- 灵活性
- 简化性

**多态存在的三个必要条件**：

- 继承
- 重写
- 父类引用指向子类对象：`Parent p = new Child();`

### 20、Java抽象（abstract）类

在 Java 中抽象类的语法格式如下：

```java
<abstract>class<class_name> {
    <abstract><type><method_name>(parameter-iist);
}
```

<font>需要注意的是 abstract 关键字只能用于普通方法，不能用于 static 方法或者构造方法中。</font>

抽象方法的 3 个特征如下：

1. 抽象方法没有方法体
2. 抽象方法必须存在于抽象类中
3. 子类重写父类时，必须重写父类所有的抽象方法

抽象类的定义和使用规则如下：

1. 抽象类和抽象方法都要使用 abstract 关键字声明。
2. 如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有 0~n 个抽象方法，以及 0~n 个具体方法。
3. 抽象类不能实例化，也就是不能使用 new 关键字创建对象。

<font title = "blue">抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</font>

<font title = "blue">继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。</font>

### 21、Java 封装

封装的优点：

1.  良好的封装能够减少耦合。
2.  类内部的结构可以自由修改。
3.  可以对成员变量进行更精确的控制。
4.  隐藏信息，实现细节。

### 22、Java 接口（Interface）

Java 接口的定义方式与类基本相同，不过接口定义使用的关键字是 interface，接口定义的语法格式如下：

```java
[public] interface interface_name [extends interface1_name[, interface2_name,…]] {
    // 接口体，其中可以包含定义常量和声明方法
    [public] [static] [final] type constant_name = value;    // 定义常量
    [public] [abstract] returnType method_name(parameter_list);    // 声明方法
}
```

> 注意：一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。
>
> 继承使用 extends 关键字，实现则使用 implements 关键字。

<font>接口与类相似点：</font>

1. 一个接口可以有多个方法。
2. 接口文件保存在 `.java `结尾的文件中，文件名使用接口名。
3. 接口的字节码文件保存在` .class `结尾的文件中。
4. 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

<font>接口与类的区别：</font>

1. 接口不能用于实例化对象。
2. 接口没有构造方法。
3. 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
4. 接口不能包含成员变量，除了 static 和 final 变量。
5. 接口不是被类继承了，而是要被类实现。
6. 接口支持多继承。

<font>接口中的成员变量只能是 **public static final** 类型的。</font>

### 23、Java匿名类

匿名类是指没有类名的内部类，必须在创建时使用 new 语句来声明类。其语法形式如下：

```java
new <类或接口>() {
    // 类的主体
};
```

匿名类有两种实现方式：

- 继承一个类，重写其方法。
- 实现一个接口（可以是多个），实现其方法。

<font title  = "blue">如果匿名类位于一个方法中，则匿名类只能访问方法中 final 类型的局部变量和参数。</font>

### 24、Java 包(package)

包的作用：

1. 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
2. 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
3. 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

import 关键字：

为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 "import" 语句可完成此功能。

```java
import package1[.package2…].(classname|*);
```